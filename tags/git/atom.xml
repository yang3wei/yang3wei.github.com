<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: git | yang3wei的专栏]]></title>
  <link href="http://yang3wei.github.com/tags/git/atom.xml" rel="self"/>
  <link href="http://yang3wei.github.com/"/>
  <updated>2013-02-01T13:45:14+08:00</updated>
  <id>http://yang3wei.github.com/</id>
  <author>
    <name><![CDATA[yang3wei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[(转载)初次运行 Git 前的配置]]></title>
    <link href="http://yang3wei.github.com/blog/2013/01/31/zhuan-zai-chu-ci-yun-xing-git-qian-de-pei-zhi/"/>
    <updated>2013-01-31T00:29:00+08:00</updated>
    <id>http://yang3wei.github.com/blog/2013/01/31/zhuan-zai-chu-ci-yun-xing-git-qian-de-pei-zhi</id>
    <content type="html"><![CDATA[<p>原文链接：<br/>
<a href="http://wuzongbin2008.blog.163.com/blog/static/214687332010111992437496/" title="人生、梦想、炼狱、天堂">http://wuzongbin2008.blog.163.com/blog/static/214687332010111992437496/</a><br/>
<a href="http://progit.org/book/zh/ch1-5.html">http://progit.org/book/zh/ch1-5.html</a><br/>
一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。<br/>
配置工作只需一次，以后升级时还会沿用现在的配置。<br/>
当然，如果需要，你随时可以用相同的命令修改已有的配置。</p>

<!-- more -->


<p>Git 提供了一个叫做 <code>git config</code> 的工具<br/>
（译注：实际是 <code>git-config</code> 命令，只不过可以通过 git 加一个名字来呼叫此命令），<br/>
专门用来配置或读取相应的工作环境变量。<br/>
而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。<br/>
这些变量可以存放在以下三个不同的地方：</p>

<h3>1.<code>/etc/gitconfig</code> 文件</h3>

<p>系统中对所有用户都普遍适用的配置。<br/>
若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</p>

<h3>2.<code>~/.gitconfig</code> 文件</h3>

<p>用户目录下的配置文件只适用于该用户。<br/>
若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</p>

<h3>3.当前项目 <code>.git</code> 隐藏目录下的 config 文件</h3>

<p>这里的配置仅仅针对当前项目有效。<br/>
每一个级别的配置都会覆盖上层的相同配置，<br/>
所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</p>

<p>在 <code>Windows</code> 系统上，Git 会找寻用户主目录下的 <code>.gitconfig</code> 文件。<br/>
主目录即 <code>$HOME</code> 变量指定的目录，一般都是 <code>C:\Documents and Settings\$USER</code>。<br/>
此外，Git 还会尝试找寻 <code>/etc/gitconfig</code> 文件，<br/>
只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>

<h2>用户信息</h2>

<p>第一个要配置的是你个人的用户名称和电子邮件地址。<br/>
这两条配置很重要，每次 Git 提交时都会引用这两条信息，<br/>
说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p>

<pre><code>git config --global user.name "John Doe"
git config --global user.email johndoe@example.com
</code></pre>


<p>如果用了 <code>--global</code> 选项，那么更改的配置文件就是位于你用户主目录下的那个，<br/>
以后你所有的项目都会默认使用这里配置的用户信息。<br/>
如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 <code>--global</code> 选项重新配置即可，<br/>
新的设定保存在当前项目的 <code>.git/config</code> 文件里。</p>

<h2>文本编辑器</h2>

<p>接下来要设置的是默认使用的文本编辑器。<br/>
Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。<br/>
默认会使用操作系统指定的默认编辑器，一般可能会是 <code>Vi</code> 或者 <code>Vim</code>。<br/>
如果你有其他偏好，比如 <code>Emacs</code> 的话，可以重新设置：</p>

<pre><code>git config --global core.editor emacs</code></pre>


<h2>差异分析工具</h2>

<p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p>

<pre><code>git config --global merge.tool vimdiff</code></pre>


<p>Git 可以理解 <code>kdiff3</code>，<code>tkdiff</code>，<code>meld</code>，<code>xxdiff</code>，<code>emerge</code>，<br/>
<code>vimdiff</code>，<code>gvimdiff</code>，<code>ecmerge</code>，<code>opendiff</code> 等合并工具的输出信息。<br/>
当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。</p>

<h2>查看配置信息</h2>

<p>要检查已有的配置信息，可以使用 git config --list 命令：</p>

<pre><code>git config --list user.name=Scott Chacon user.email=schacon@gmail.com color.status=auto color.branch=auto color.interactive=auto color.diff=auto ...</code></pre>


<p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件<br/>
（比如 <code>/etc/gitconfig</code> 和 <code>~/.gitconfig</code>），不过最终 Git 实际采用的是最后一个。</p>

<p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p>

<pre><code>git config user.name Scott Chacon</code></pre>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git 笔记概览]]></title>
    <link href="http://yang3wei.github.com/blog/2013/01/29/git-bi-ji-gai-lan/"/>
    <updated>2013-01-29T16:12:00+08:00</updated>
    <id>http://yang3wei.github.com/blog/2013/01/29/git-bi-ji-gai-lan</id>
    <content type="html"><![CDATA[<!-- more -->


<h3>Git 如何删除 Remote 的文件</h3>

<p><a href="http://yang3wei.github.com/blog/2013/01/28/zhuan-zai-git-ru-he-shan-chu-remote-de-wen-jian/" title="(转载)Git 如何删除 Remote 的文件">Git 如何删除 Remote 的文件</a></p>

<h3>git - 简易指南</h3>

<p><a href="http://rogerdudler.github.com/git-guide/index.zh.html" title="git - 简易指南">助你开始使用 git 的简易指南，木有高深内容，;)</a></p>

<h3>git 删除远程分支的命令</h3>

<p>如果通过命令 <code>git branch -b feature_x source</code> 建立了 source 的一个分支 feature_x，<br/>
而且还将 feature_x 这个分支提交到 github 服务器上面去了，<br/>
此时由 feature_x 切换回 source 分支后执行 <code>git branch -d feature_x</code> 命令只能删除本地分支，<br/>
怎么将 github 服务器上面的 feature_x 分支给干掉呢？<br/>
执行 <code>git push origin :feature\_x</code> 命令即可！</p>

<h3>Git 分支管理策略</h3>

<p><a href="http://yang3wei.github.com/blog/2013/01/29/zhuan-zai-git-fen-zhi-guan-li-ce-lue/" title="Git 分支管理策略">Git 分支管理策略</a></p>

<h3>Git 怎么为 github 生成 ssh 密钥</h3>

<p><a href="https://help.github.com/articles/generating-ssh-keys" title="Generating SSH Keys">github:help - Generating SSH Keys</a></p>

<h3>Git 恢复删掉的一个文件</h3>

<p>删除一个文件：<br/>
<code>git rm 5.c</code><br/>
现在要恢复：<br/>
<code>git reset HEAD 5.c</code><br/>
<code>git checkout 5.c</code><br/>
完成（HEAD 似乎表示当前分支的当前版本）</p>

<h3>Git 在各版本之间自由穿梭</h3>

<p>恢复到上一个提交的版本<br/>
<code>git reset --hard HEAD^</code><br/>
恢复到某一个提交的版本<br/>
<code>git reset --hard e0dea1a7eaca4b9325e36fdbdf0909d02a067d43</code><br/>
<strong>注：各版本的 <code>hash</code> 可以去 <code>github</code> 查看，也可以使用 <code>git log</code> 命令查看。</strong></p>

<h3>Git 怎么忽略某个文件</h3>

<p>仓库的 <code>.gitignore</code> 或 <code>git/info/exclude</code>，<code>exclude</code> 本身不被 <code>git</code> 管理。<br/>
一般情况下不要使用第一种方法，因为 <code>.gitignore</code> 本身是被 <code>git</code> 管理的，是大家共用的。<br/>
所以，不要随便修改 <code>.gitignore</code> 文件！</p>

<h3>Yasin Lee 的 git 学习笔记</h3>

<p><a href="http://blog.csdn.net/coder_jack/article/details/5975070#">http://blog.csdn.net/coder_jack/article/details/5975070#</a></p>

<h3>Problem with "git remote add origin git@github.com:yang3wei/test.git"？</h3>

<p>试着先执行一下 <code>git remote rm origin</code> 命令。<br/>
<a href="http://stackoverflow.com/questions/10904339/github-fatal-remote-origin-already-exists">github-fatal-remote-origin-already-exists</a></p>

<h3>fatal: ... did you run git update-server-info on the server?</h3>

<p>You have to carefully look after your spelling. <br/>
According to Github's guide, your username is nalgene, <br/>
hence the URL is <code>https://github.com/nalgene/MultiView.git</code>. <br/>
The error message hints that you added the remote as <br/>
<code>https://github.com/naglene/MultiView.git</code> <br/>
which is not the same username, as you swapped the <code>l</code> and <code>g</code>.<br/>
Also, the default branch is called <code>master</code>, not <code>maaster</code> or <code>mater</code>.<br/>
<a href="http://stackoverflow.com/questions/11094547/fatal-https-github-com-user-repo-git-info-refs-not-found-did-you-run-git-upd">original link</a></p>

<h3>What does "origin" mean in "git push origin master"?</h3>

<p><code>git push origin master</code> 的完整命令如下：<br/>
<code>git push git@github.com:{username}/{projectname}.git HEAD:{branchname}</code></p>

<p>Also, you don't need to type out the whole url each time you want to push. <br/>
When you ran the clone, git saved that URL as <code>origin</code>, <br/>
that's why you can run something like 'merge origin/test' - <br/>
it means the <code>test</code> branch on your <code>origin</code> server. <br/>
So, the simplest way to push to your server in that case would be:<br/>
<code>git push origin my_test:test</code><br/>
That will push your local <code>my_test</code> branch to the <code>test</code> branch on your <code>origin</code> server. <br/>
If you had named your local branch the same as the branch on the server, <br/>
then the colon is not neccesary, you can simply do:<br/>
<code>git push origin test</code><br/>
<a href="http://stackoverflow.com/questions/959477/error-when-git-push-to-github">Error when “git push” to github</a></p>

<h2>#</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(转载)Git 分支管理策略]]></title>
    <link href="http://yang3wei.github.com/blog/2013/01/29/zhuan-zai-git-fen-zhi-guan-li-ce-lue/"/>
    <updated>2013-01-29T15:21:00+08:00</updated>
    <id>http://yang3wei.github.com/blog/2013/01/29/zhuan-zai-git-fen-zhi-guan-li-ce-lue</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" title="阮一峰的网络日志">http://www.ruanyifeng.com/blog/2012/07/git.html</a><br/>
如果你严肃对待编程，就必定会使用"版本管理系统"（Version Control System）。
眼下最流行的"版本管理系统"，非 Git 莫属。<br/>
<img src="/images/posts/bg2012070501.png" alt="cool git" /></p>

<!-- more -->


<p>相比同类软件，Git 有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而 Git 只生成一个指向当前版本（又称"快照"）的指针，因此非常快捷易用。
但是，太方便了也会产生副作用。如果你不加注意，很可能会留下一个枝节蔓生、四处开放的版本库，到处都是分支，完全看不出主干发展的脉络。<br/>
<img src="/images/posts/bg2012070502.png" alt="cool git" /><br/>
Vincent Driessen提出了一个分支管理的策略，我觉得非常值得借鉴。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。理论上，这些策略对所有的版本管理系统都适用，Git 只是用来举例而已。如果你不熟悉 Git，跳过举例部分就可以了。</p>

<h2>一、主分支 Master</h2>

<p>首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。<br/>
<img src="/images/posts/bg2012070503.png" alt="cool git" /><br/>
Git 主分支的名字，默认叫做 Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。</p>

<h2>二、开发分支 Develop</h2>

<p>主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做 Develop。<br/>
<img src="/images/posts/bg2012070504.png" alt="cool git" /><br/>
这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在 Master 分支上，对 Develop 分支进行"合并"（merge）。
Git 创建 Develop 分支的命令：</p>

<pre><code>git checkout -b develop master</code></pre>


<p>将 Develop 分支发布到 Master 分支的命令：</p>

<pre><code># 切换到 Master 分支
git checkout master
# 对 Develop 分支进行合并
git merge --no-ff develop</code></pre>


<p>这里稍微解释一下，上一条命令的 --no-ff 参数是什么意思。默认情况下，Git 执行"快进式合并"（fast-farward merge），会直接将 Master 分支指向 Develop 分支。<br/>
<img src="/images/posts/bg2012070505.png" alt="cool git" /><br/>
使用 --no-ff 参数后，会执行正常合并，在 Master 分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。关于合并的更多解释，请参考 Benjamin Sandofsky的《Understanding the Git Workflow》。<br/>
<img src="/images/posts/bg2012070506.png" alt="cool git" /></p>

<h2>三、临时性分支</h2>

<p>前面讲到版本库的两条主要分支：Master 和 Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。
但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：
　　<em> 功能（feature）分支
　　</em> 预发布（release）分支
　　* 修补bug（fixbug）分支
这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有 Master 和 Develop。</p>

<h2>四、 功能分支</h2>

<p>接下来，一个个来看这三种 "临时性分支"。
第一种是功能分支，它是为了开发某种特定功能，从 Develop 分支上面分出来的。开发完成后，要再并入 Develop。<br/>
<img src="/images/posts/bg2012070507.png" alt="cool git" /><br/>
功能分支的名字，可以采用 feature-* 的形式命名。
创建一个功能分支：</p>

<pre><code>git checkout -b feature-x develop</code></pre>


<p>开发完成后，将功能分支合并到 develop 分支：</p>

<pre><code>git checkout develop
git merge --no-ff feature-x</code></pre>


<p>删除 feature 分支：</p>

<pre><code>git branch -d feature-x</code></pre>


<h2>五、预发布分支</h2>

<p>第二种是预发布分支，它是指发布正式版本之前（即合并到 Master 分支之前），我们可能需要有一个预发布的版本进行测试。
预发布分支是从 Develop 分支上面分出来的，预发布结束以后，必须合并进 Develop 和 Master 分支。它的命名，可以采用 release-* 的形式。
创建一个预发布分支：</p>

<pre><code>git checkout -b release-1.2 develop</code></pre>


<p>确认没有问题后，合并到 master 分支：</p>

<pre><code>git checkout master
git merge --no-ff release-1.2
# 对合并生成的新节点，做一个标签
git tag -a 1.2</code></pre>


<p>再合并到 develop 分支：</p>

<pre><code>git checkout develop
git merge --no-ff release-1.2</code></pre>


<p>最后，删除预发布分支：</p>

<pre><code>git branch -d release-1.2</code></pre>


<p>六、修补 bug 分支
最后一种是修补 bug 分支。软件正式发布以后，难免会出现 bug。这时就需要创建一个分支，进行 bug 修补。
修补 bug 分支是从 Master 分支上面分出来的。修补结束以后，再合并进 Master 和 Develop 分支。它的命名，可以采用 fixbug-* 的形式。<br/>
<img src="/images/posts/bg2012070508.png" alt="cool git" /><br/>
创建一个修补 bug 分支：</p>

<pre><code>git checkout -b fixbug-0.1 master</code></pre>


<p>修补结束后，合并到 master 分支：</p>

<pre><code>git checkout master
git merge --no-ff fixbug-0.1
git tag -a 0.1.1</code></pre>


<p>再合并到 develop 分支：</p>

<pre><code>git checkout develop
git merge --no-ff fixbug-0.1</code></pre>


<p>最后，删除 "修补 bug 分支"：</p>

<pre><code>git branch -d fixbug-0.1</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(转载)Git 如何删除 Remote 的文件]]></title>
    <link href="http://yang3wei.github.com/blog/2013/01/28/zhuan-zai-git-ru-he-shan-chu-remote-de-wen-jian/"/>
    <updated>2013-01-28T17:25:00+08:00</updated>
    <id>http://yang3wei.github.com/blog/2013/01/28/zhuan-zai-git-ru-he-shan-chu-remote-de-wen-jian</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://hi.baidu.com/zairl23/item/4a34c60084108fd01ef0464d" title="The Way">http://hi.baidu.com/zairl23/item/4a34c60084108fd01ef0464d</a><br/>
使用 toto 做了个博客挂着 heroku 上。<br/>
使用 git push 的方法发布博客确实有点cool。<br/>
可是发现以前删除的测试文件仍然在, 如何将他们通过 git 的方式删除呢?<br/>
不止是 heroku, 我发现 github 上也保留有我删除掉的文件.<br/>
由于某些原因，git 远程的文件与本地文件产生了不一致，现在需要删除远程的一个文件：</p>

<!-- more -->


<p>通过使用：</p>

<pre><code>git status</code></pre>


<p>
得到下面的信息：<br/>
<strong># On branch master<br/>
# Changes not staged for commit:<br/>
#   (use "git add/rm <file>..." to update what will be committed)<br/>
#   (use "git checkout -- <file>..." to discard changes in working directory)<br/>
# deleted:    app/assets/stylesheets/base.css<br/>
# deleted:    app/assets/stylesheets/blue.css<br/>
 no changes added to commit (use "git add" and/or "git commit -a")</strong></p>

<p>即是说，base.css 和 blue.css 两个文件已经在本地删除，却因为没有 commit，而还在远程的 git 里面了，那么重新执行：</p>

<pre><code>git rm app/assets/stylesheets/base.css</code></pre>


<p>
显示：<br/>
<strong>rm 'app/assets/stylesheets/base.css'</strong></p>

<pre><code>git rm app/assets/stylesheets/blue.css</code></pre>


<p>
显示：<br/>
<strong>rm 'app/assets/stylesheets/blue.css'</strong></p>

<p>现在要 commit 了：</p>

<pre><code>git commit -m 'delete base-blue css'</code></pre>


<p>
显示：<br/>
<strong>[master 41124a8] delete base-blue css
2 files changed, 0 insertions(+), 690 deletions(-)
delete mode 100644 app/assets/stylesheets/base.css
delete mode 100644 app/assets/stylesheets/blue.css</strong></p>

<p>然后提交：</p>

<pre><code>git push origin master</code></pre>


<blockquote></blockquote>

<p>ok 了。总结一下：<br/>
多运行 git staus 查看有没有未曾 commit 过的文件，<br/>
因为在 git 里面，只有 commit，你才能够 push 成功的!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(转载)在 github 上使用 octopress]]></title>
    <link href="http://yang3wei.github.com/blog/2013/01/28/zhuan-zai-zai-github-shang-shi-yong-octopress/"/>
    <updated>2013-01-28T14:46:00+08:00</updated>
    <id>http://yang3wei.github.com/blog/2013/01/28/zhuan-zai-zai-github-shang-shi-yong-octopress</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://huanggang.me/archives/654" title="海阔天空">http://huanggang.me/archives/654</a></p>

<h2>一、Octopress 简介</h2>

<p>Octopress 是使用 ruby 语言编写的一套建立在 jekyll 之上的博客系统，它有一些很独特的特点：</p>

<pre><code>1. 使用静态页面；
2. 不使用数据库；
3. 使用 markdown 标记语言编写文章；
4. 可以与 git 紧密集成，方便地进行博客的版本管理；
5. 可以于 Github Pages 集成，不需要单独的 web hosting，只要你有 github 帐号即可。
</pre>


<p></code>
这些特点中的第三点到第五点尤其吸引我（第一点和第二点也很酷），于是我花了些时间研究。<br/>
以下是相关的步骤和心得。</p>

<!-- more -->


<p></p>

<h2>二、在你本地安装 octopress</h2>

<p>说“安装”可能不太恰当，准确的说是你需要从 github 上取得 octopress 的代码并进行些许配置。步骤请参考这里。</p>

<ol>
<li><p>安装 RVM(Ruby Version Manager) 并使用”Ruby 1.9.2″作为你本地的 ruby 实现，<br/>
这事我之前按照这篇文章做过，这里就不详细说了，你也可以按照octopress官方的介绍来安装RVM。</p></li>
<li><p>从 github 得到 octopress 代码，运行以下命令：</p></li>
</ol>


<pre><code>git clone git://github.com/imathis/octopress.git octopress
cd octopress    # If you use RVM, You'll be asked if you trust the .rvmrc file (say yes).
ruby --version  # Should report Ruby 1.9.2

gem install bundler # Install dependencies
bundle install

rake install # Install the default Octopress theme
</pre>


<p></code></p>

<h2>三、配置你本地的 octopress，使之可以发布到你的 github pages</h2>

<p>这样就可以做到：<br/>
你在本地创建博客文章(当然是用 markdown 写成的)，然后直接 deploy 到你的 github pages repo，github会自动进行发布。<br/>
也就是说：所有发博客的动作只需要在你本地用命令完成，酷吧！</p>

<p>参考了这里。</p>

<ol>
<li>创建你的 github pages repo</li>
</ol>


<p>如果你的 github 用户名是 username，那个就创建一个名称为”username.github.com”的repo，
这个 repo 就是你的 github pages repo，更多信息可以参考这里。</p>

<ol>
<li>在你本地运行以下命令，octopress 会自动帮你进行配置：</li>
</ol>


<pre><code>cd your_local_octopress_directory
rake setup_github_pages
</pre>


<p></code></p>

<p>注意：当命令提示你输入github URL时，请使用这个格式的URL:<br/>
<code>git@github.com:username/username.github.com.git</code></p>

<p>当这个命令运行完成之后，你的github pages repo会有两个branches:<br/>
master branch 用于静态页面的发布(“octopress/<em>deploy”的内容)，<br/>
source branch 用于保存你的 blog 内容（”octopress”目录中除了”</em>deploy”的其它内容）</p>

<p>到这里基本的配置就完成了，你还可以参考这里配置你博客的名称等信息。</p>

<h2>四、编写并发布文章</h2>

<p>请参考这里。</p>

<ol>
<li>写文章</li>
</ol>


<pre><code>cd your_local_octopress_directory
rake new_post["Your Title of Your Article"]
</pre>


<p></code>
该命令会在你的”octopress/source/_posts”目录下生成对应的”.markdown”文件，<br/>
用任意文本编辑器编辑，使用 markdown 语法编写你的文章。</p>

<ol>
<li>生成，预览并发布：</li>
</ol>


<pre><code>cd your_local_octopress_directory
rake generate
rake preview
rake deploy
</pre>


<p></code>
rake generate 命令用于将 markdown 文件转化为静态页面
rake preview 命令用于打开一个 web server 供你预览编写的页面效果如何，通过 “http://localhost:4000”进行访问
rake deploy 命令用于将生成的静态页面内容提交到 github 的 repo（“master”branch）</p>

<p>还有很重要的一步是把你的修改(文本修改，不包含”_deploy”目录，”deploy”目录保存”rake generate”生成的静态页面内容，会被”rake deploy”命令提交到”master branch”)放到你的github pages(“source” branch)上:</p>

<pre><code>cd your_local_octopress_directory
git add .
git commit -m 'your message'
git push origin source
</pre>


<p></code>
—–EOF—–</p>
]]></content>
  </entry>
  
</feed>
