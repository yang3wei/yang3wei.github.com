<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: git | yang3wei的专栏]]></title>
  <link href="http://yang3wei.github.com/tags/git/atom.xml" rel="self"/>
  <link href="http://yang3wei.github.com/"/>
  <updated>2013-02-03T15:03:00+08:00</updated>
  <id>http://yang3wei.github.com/</id>
  <author>
    <name><![CDATA[yang3wei]]></name>
    <email><![CDATA[88480585@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA["git rm" 和 "rm" 的区别]]></title>
    <link href="http://yang3wei.github.com/blog/2013/02/03/git-rm-he-rm-de-qu-bie/"/>
    <updated>2013-02-03T14:01:00+08:00</updated>
    <id>http://yang3wei.github.com/blog/2013/02/03/git-rm-he-rm-de-qu-bie</id>
    <content type="html"><![CDATA[<p>这是一个比较肤浅的问题，但对于 git 初学者来说，还是有必要提一下的。</p>

<!-- more -->


<p>用 <code>git rm</code> 来删除文件，同时还会将这个删除操作记录下来；<br/>
用 <code>rm</code> 来删除文件，仅仅是删除了物理文件，没有将其从 git 的记录中剔除。</p>

<p>直观的来讲，<code>git rm</code> 删除过的文件，执行 <code>git commit -m "abc"</code> 提交时，<br/>
会自动将删除该文件的操作提交上去。</p>

<p>而对于用 <code>rm</code> 命令直接删除的文件，执行 <code>git commit -m "abc"</code> 提交时，<br/>
则不会将删除该文件的操作提交上去。<br/>
不过不要紧，即使你已经通过 <code>rm</code> 将某个文件删除掉了，<br/>
也可以再通过 <code>git rm</code> 命令重新将该文件从 git 的记录中删除掉，<br/>
这样的话，在执行 <code>git commit -m "abc"</code> 以后，也能将这个删除操作提交上去。</p>

<p>如果之前不小心用 <code>rm</code> 命令删除了一大批文件呢？<br/>
是的，此时用 <code>git rm</code> 逐个地再删除一次就显得相当蛋疼了。<br/>
所幸还有更方便的处理方案，用如下的方式做提交就没有问题了：
<code>git commit -am "abc"</code></p>

<h3>总结一下：</h3>

<p>在被 git 管理的目录中删除文件时，可以选择如下两种方式来记录删除动作：<br/>
一、<code>rm</code> + <code>git commit -am "abc"</code><br/>
二、<code>git rm</code> + <code>git commit -m "abc"</code><br/>
另外，<code>git add .</code> 仅能记录添加、改动的动作，删除的动作需靠 <code>git rm</code> 来完成。<br/>
最后，<code>rm</code> 删除的文件是处于 <code>not staged</code> 状态的，<br/>
也就是一种介于 “未改动” 和 “已提交过” 之间的状态。</p>

<h3>下面是测试图</h3>

<p>一、<code>git rm</code> 与 <code>rm</code> 之间的区别
<img class="center" src="/images/posts/differences_btw_git_rm_and_rm.png">
二、<code>git add .</code> 无法记录 <code>rm</code> 删除动作<br/>
<img class="center" src="/images/posts/add_dot_make_no_use.png">
三、<code>git commit -m "abc"</code> 无法提交 <code>rm</code> 删除动作<br/>
<img class="center" src="/images/posts/git_rm_better_than_rm.png">
四、<code>git commit -am "abc"</code> 中参数 a 的作用<br/>
<img class="center" src="/images/posts/usage_of_flag_a.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git-credential-osxkeychain died of signal 11 解决方案]]></title>
    <link href="http://yang3wei.github.com/blog/2013/02/03/git-credential-osxkeychain-died-of-signal-11-jie-jue-fang-an/"/>
    <updated>2013-02-03T00:30:00+08:00</updated>
    <id>http://yang3wei.github.com/blog/2013/02/03/git-credential-osxkeychain-died-of-signal-11-jie-jue-fang-an</id>
    <content type="html"><![CDATA[<p>相关帖子链接：<br/>
<a href="http://stackoverflow.com/questions/14272634/error-git-credential-osxkeychain-died-of-signal-11/14663780#14663780">...osxkeychain-died-of-signal-11@stackoverflow.com</a><br/>
前两天在执行 <code>git push origin master</code> 命令的时候突然发现不灵光了，<br/>
死活都推不进 GitHub 服务器，给出的提示如下：<br/>
<code>error: git-credential-osxkeychain died of signal 11</code><br/>
<code>error: git-credential-osxkeychain died of signal 11</code></p>

<!-- more -->


<p>我没有弄错，给出了两行一模一样的提示。<br/>
遇到这个问题以后我的第一反应就是 googling，<br/>
直接就找到了文首给出的那个 stackoverflow 的帖子。</p>

<p>不过这个帖子并没有帮我解决掉这个问题，然后我又继续 googling，<br/>
没有太大的收获，涉及到相关问题的链接不是很多。。<br/>
我一度多次打开 stackoverflow 的这个帖子，仔细的搜寻，<br/>
想看一看我是否遗忘了什么重要的步骤，不过很可惜，没有发现有价值的情报。</p>

<p>后来我计上心头，想到了一个好办法，<br/>
去试一试另外一个本地目录的 work copy 能否推到 GitHub 服务器里面去。<br/>
我做了一些变更并且提交过以后，就执行 “git push origin master” 命令，<br/>
很奇葩的没有出错，也没有向我询问用户名和密码~</p>

<p>到这里我就有点儿纳闷儿了，凭什么这里可以那儿却不行？！<br/>
纠结了好几天了，今天突然又想到一个办法，<br/>
怎么不对比一下两个 work copy 的 .git/config 文件呢，说不定有有所收获！<br/>
果不其然，经我对比过后我发现两个 work copy 所采用的配置有所不同。<br/>
区别在哪里呢？下面我给出来对比一下吧：<br/>
<strong>这里是 push 时抛错的那个 work copy 的 .git/config 文件的部分配置</strong></p>

<pre><code>...
[remote "origin"]
    url = https://github.com/yang3wei/octopress-3-in-one.git
    fetch = +refs/heads/*:refs/remotes/origin/*
...
</code></pre>


<p><strong>这里是 push 时没问题的 work copy 的 .git/config 文件对应的部分配置</strong></p>

<pre><code>...
[remote "origin"]
    url = git@github.com:yang3wei/game-development-tools
    fetch = +refs/heads/*:refs/remotes/master/*
...
</code></pre>


<p>对比后我就多少有些念想了，何不试着把有问题的照着没问题的改弄一翻？<br/>
说干就干，于是我就将有问题的那块儿配置改成了如下这番：</p>

<pre><code>
[remote "origin"]
    url = git@github.com/yang3wei/octopress-3-in-one
    fetch = +refs/heads/*:refs/remotes/origin/*
...
</code></pre>


<p>然后再执行 <code>git push origin master</code> 命令，发现那该死的错误已经悄然遁去~</p>

<h3>总结一下</h3>

<p>一言以蔽之，就是更换了一下 .git/config 中 url 的写法而已，<br/>
将 <code>url = https://github.com/yang3wei/octopress-3-in-one.git</code><br/>
改为 <code>url = git@github.com:yang3wei/octopress-3-in-one</code><br/>
说到这里，我隐约想起好像看到过一句话：<br/>
ssh 加密传输好像是非后面那种 url 格式不可的，<br/>
那么从这点来看的话，<br/>
<code>git-credential-osxkeychain</code> 在 https 传输模式下出错也就情有可原了~<br/>
最后，创建属于自己的 repo 的时候，<br/>
最好还是能以 <code>git@github.com...</code> 这种 url 的写法来初始化仓库，<br/>
以避免当前讨论这种问题的出现~</p>

<h3>另外</h3>

<p>其间也试了下将<br/>
<code>fetch = +refs/heads/*:refs/remotes/origin/*</code><br/>
改为<br/>
<code>fetch = +refs/heads/*:refs/remotes/master/*</code><br/>
如此这般以后我执行 <code>git push origin master</code> 也没有出现错误~<br/>
不过后来在我查看的时候发现竟然多出了一个分支：<br/>
<code>* master</code><br/>
<code> remotes/master/master/</code><br/>
<code> remotes/origin/master/</code><br/>
显而易见，那里我不该将 fetch 里面的 origin 改成 master，<br/>
这里直接导致我远程那边多出了一个无用的分支来~<br/>
话说这里该如何将这个多余的远程分支 <code>remotes/master/master</code> 给干掉呢？<br/>
记得删除远程服务器上面的分支可以用这条命令：<code>git push origin :branchname</code><br/>
不过这里比较特殊，这条多余分支的名字也是 <code>master</code> 呢！<br/>
搜寻良久，stackoverflow 再次帮了我一把，实在是给力啊！下面是相关链接：<br/>
<a href="http://stackoverflow.com/questions/1072171/how-do-you-remove-an-invalid-remote-branch-reference-from-git">How do you Remove an Invalid Remote Branch Reference from Git?</a><br/>
罗列出我所尝试的删除分支的命令：<br/>
<code>git branch -d remotes/master/master</code> 报错<br/>
<code>git push master :master</code> 报错<br/>
<code>git push origin :/remotes/master/master</code> 报错
<code>git gc --prune=now</code> 无效<br/>
<code>git remote rm master</code> 报错<br/>
<code>git branch -rd master/master</code> 删除成功！</p>

<h3>执行 git status 命令后出现如下提示的涵义</h3>

<pre><code># On branch master
# Your branch is ahead of 'origin/master' by 1 commit.
#   (use "git push" to publish your local commits)
#
nothing to commit, working directory clean
</code></pre>


<p>回忆起前几天对 git 不熟悉时因为老是看到这几行提示而感到心里不舒服的情景，<br/>
才发现我真是傻得可爱，这些提示的意思不就是说：<br/>
<strong>你当前有 1 个已完成的提交还没推到远程服务器，执行 push 命令来推出已完成的提交</strong><br/>
哎，那天也不知道是怎么了，肯定是发现和平时不一样却没有仔细看就匆忙下了定论，<br/>
今后得把这种粗细大意的毛病给改掉~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 与 SVN 之间的五个基本区别]]></title>
    <link href="http://yang3wei.github.com/blog/2013/02/02/git-yu-svn-zhi-jian-de-wu-ge-ji-ben-qu-bie/"/>
    <updated>2013-02-02T18:03:00+08:00</updated>
    <id>http://yang3wei.github.com/blog/2013/02/02/git-yu-svn-zhi-jian-de-wu-ge-ji-ben-qu-bie</id>
    <content type="html"><![CDATA[<p>原文链接：<br/>
<a href="http://blog.csdn.net/dadoneo/article/details/6098540">http://blog.csdn.net/dadoneo/article/details/6098540</a><br/>
在比较两者之前，可以阅读：<br/>
<a href="rubynroll.javaeye.com/blog/203133">SVN + GIT = 鱼与熊掌兼得</a><br/>
<a href="wenku.baidu.com/view/dd6d36eef8c75fbfc77db277.html">开源版本控制 SVN 用户严重的 git</a><br/>
<a href="www.robinlu.com/blog/archives/194">如何在 SVN 系统中使用 git</a></p>

<!-- more -->


<p>如果你在读这篇文章，说明你跟大多数开发者一样对 GIT 感兴趣，<br/>
如果你还没有机会来试一试 GIT，我想现在你就要了解它了。</p>

<p>GIT 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。<br/>
如果你是一个具有使用 SVN 背景的人，<br/>
你需要做一定的思想转换，来适应 GIT 提供的一些概念和特征。<br/>
所以，这篇文章的主要目的就是通过介绍 GIT 能做什么、<br/>
它和 SVN 在深层次上究竟有什么不同来帮助你认识它。</p>

<p>那好，这就开始吧...</p>

<h2>1.GIT 是分布式的，SVN 不是：</h2>

<p>这是 GIT 和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。<br/>
如果你能理解这个概念，那么你就已经上手一半了。<br/>
需要做一点声明，GIT 并不是目前第一个或唯一的分布式版本控制系统。<br/>
还有一些系统，例如 Bitkeeper, Mercurial 等，也是运行在分布式模式上的。<br/>
但 GIT 在这方面做的更好，而且有更多强大的功能特征。</p>

<p>GIT 跟 SVN 一样有自己的集中式版本库或服务器。<br/>
但，GIT 更倾向于被使用于分布式模式，也就是每个开发人员从中心<br/>
版本库/服务器上 chect out 代码后会在自己的机器上克隆一个自己的版本库。<br/>
可以这样说，如果你被困在一个不能连接网络的地方时，就像在飞机上，地下室，<br/>
电梯里等，你仍然能够提 交文件，查看历史版本记录，创建项目分支，等。<br/>
对一些人来说，这好像没多大用处，但当你突然遇到没有网络的环境时，这个将解决你的大麻烦。</p>

<p>同样，这种分布式的操作模式对于开源软件社区的开发来说也是个巨大的恩赐，你不必再像以前那样做出补丁包，<br/>
通过 email 方式发送出去，你只需要创建一个分支，向项目团队发送一个推请求。<br/>
这能让你的代码保持最新，而且不会在传输过程中丢失。GitHub.com 就是一个这样的优秀案例。</p>

<p>有些谣言传出来说 Subversion 将来的版本也会基于分布式模式。但至少目前还看不出来。</p>

<h2>2.GIT 把内容按元数据方式存储，而 SVN 是按文件：</h2>

<p>所有的资源控制系统都是把文件的元信息隐藏在一个类似 <code>.svn</code>，<code>.cvs</code> 等的文件夹里。<br/>
如果你把 <code>.git</code> 目录的体积大小跟 <code>.svn</code> 比较，你会发现它们差距很大。<br/>
因为，<code>.git</code> 目录是处于你的机器上的一个克隆版的版本库，<br/>
它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。</p>

<h2>3.GIT 分支和 SVN 的分支不同：</h2>

<p>分支在 SVN 中一点不特别，就是版本库中的另外的一个目录。如果你想知道是否合并了一个分支，<br/>
你需要手工运行像这样的命令 svn propget svn:mergeinfo，来确认代码是否被合并。<br/>
感谢 Ben 同学指出这个特征。所以，经常会发生有些分支被遗漏的情况。<br/>
然而，处理 GIT 的分支却是相当的简单和有趣。你可以从同一个工作目录下快速的在几个分支间切换。<br/>
你很容易发现未被合并的分支，你能简单而快捷的合并这些文件。</p>

<h2>4.GIT 没有一个全局的版本号，而 SVN 有：</h2>

<p>目前为止这是跟 SVN 相比 GIT 缺少的最大的一个特征。<br/>
你也知道，SVN 的版本号实际是任何一个相应时间的源代码快照。<br/>
我认为它是从 CVS 进化到 SVN 的最大的一个突破。<br/>
因为 GIT 和 SVN 从概念上就不同，我不知道 GIT 里是什么特征与之对应。<br/>
如果你有任何的线索，请在评论里奉献出来与大家共享。<br/>
更新：有些读者指出，我们可以使用 GIT 的 SHA-1 来唯一的标识一个代码快照。<br/>
这个并不能完全的代替 SVN 里容易阅读的数字版本号。但，用途应该是相同的。</p>

<h2>5.GIT 的内容完整性要优于 SVN：</h2>

<p>GIT 的内容存储使用的是 SHA-1 哈希算法。<br/>
这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。<br/>
这里有一个很好的关于 GIT 内容完整性的讨论 – <br/>
<a href="http://stackoverflow.com/questions/964331/git-file-integrity">http://stackoverflow.com/questions/964331/git-file-integrity</a></p>

<h2>GIT 和 SVN 之间只有这五处不同吗？</h2>

<p>当然不是。我想这五个只是 “最基本的” 和 “最吸引人” 的，我只想到这五点。<br/>
如果你发现有比这五点更有趣的，请共享出来，欢迎。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(转载)很好的一篇 git 入门文章]]></title>
    <link href="http://yang3wei.github.com/blog/2013/02/02/zhuan-zai-hen-hao-de-%5B%3F%5D-pian-git-ru-men-wen-zhang/"/>
    <updated>2013-02-02T00:00:00+08:00</updated>
    <id>http://yang3wei.github.com/blog/2013/02/02/zhuan-zai-hen-hao-de-[?]-pian-git-ru-men-wen-zhang</id>
    <content type="html"><![CDATA[<p>原文链接：<br/>
<a href="http://blog.csdn.net/ylm23_24/article/details/8561527">http://blog.csdn.net/ylm23_24/article/details/8561527</a><br/>
用了几次 git 了，一直没总结，还是不太熟。<br/>
下载和安装什么的就不说了。<br/>
Windows 下推荐 git 和 tortoise git。Linux 下的 gitk 貌似还不错。</p>

<!-- more -->


<h3>1.本地创建新仓库</h3>

<p>创建新文件夹，打开终端执行<br/>
<code>git init</code></p>

<p>这样就创建了一个新的 git 仓库</p>

<h3>2.复制仓库</h3>

<p>本地复制，创建一个本地仓库的克隆版本。<br/>
<code>git clone /path/to/repository</code></p>

<p>将远端服务器上的仓库复制到本地，就跟下载差不多，如下例<br/>
<code>git clone git@github.com:linus-young/depot.git</code></p>

<h3>3.添加与提交</h3>

<p><code>git add filename</code><br/>
<code>git commit -m "代码提交信息"</code></p>

<h3>4.推送到远端服务器</h3>

<p>在 github 上申请一个帐号，create a new repo，<br/>
创建之后其实 github 上有提示要执行哪些命令，注意两个邮箱需一致。<br/>
至于本地的配置详见 <a href="http://blog.csdn.net/ylm23_24/article/details/8297362">http://blog.csdn.net/ylm23_24/article/details/8297362</a><br/>
在当前本地文件夹下执行：<br/>
<code>git remote add origin git@github.com:linus-young/depot.git</code><br/>
<code>git push origin master</code></p>

<p>第一行代码是确定添加到 github 的哪个仓库，作为第一次提交。<br/>
第二行是将本地的所有文件上传到远端服务器上。<br/>
master 是默认分支，可改为其他分支。本地创建的其他分支默认是不可见的。</p>

<h3>5.分支</h3>

<p>master 是默认的。在其他分支上进行开发，完成后再合并到主分支上，有利于多人共同开发。<br/>
在当前本地仓库新建一个分支 test<br/>
<code>git branch test</code><br/>
若此时运行<br/>
<code>git branch</code></p>

<p>可以看到所有当前存在的分支<br/>
test<br/>
*master</p>

<p>切换到 test 分支<br/>
<code>git checkout test</code><br/>
现在来随便更改一些文件，并且提交，然后切换到 master<br/>
<strong>(edit file)</strong><br/>
<code>git commit -a -m "try branch"</code><br/>
<code>git checkout master</code></p>

<p>切换之后你打开刚刚修改过的文件，神奇的是貌似这些文件都没有被修改过！<br/>
原因是你此时处于 master 分支，test 分支里面所作的改动是不起作用的，不信的话可以用<br/>
<code>git checkout test</code><br/>
然后看看文件是否被修改了</p>

<p>然后你可以修改 master 分支下的一些文件并且提交<br/>
<strong>(edit file)</strong><br/>
<code>git commit -a -m "i just edit some file on master"</code></p>

<p>然后我们来合并 test 分支上的改动到 master 下<br/>
<code>git merge test</code></p>

<p>报错的话可以用 git diff 查看冲突<br/>
然后提交<br/>
<code>git commit -a -m "i have merged test to master"</code></p>

<p>下面这行可以删除 test 分支：<br/>
<code>git branch -d test</code></p>

<h3>6.其他常见命令</h3>

<p><code>git status</code> 查看文件状态<br/>
<code>git log</code>   查看提交的历史记录<br/>
<code>git pull</code> 和 <code>git push</code> 相反</p>

<h3>7.gitk</h3>

<p><code>gitk</code> 可以用图形化的方式很清楚地显示改动</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(转载)Git: Why 'Everything up-to-date' when pushing]]></title>
    <link href="http://yang3wei.github.com/blog/2013/02/01/git-why-everything-up-to-date-when-pushing/"/>
    <updated>2013-02-01T23:22:00+08:00</updated>
    <id>http://yang3wei.github.com/blog/2013/02/01/git-why-everything-up-to-date-when-pushing</id>
    <content type="html"><![CDATA[<p>原文链接：<br/>
<a href="http://blog.rexzhao.com/2011/11/28/google-code-git-everything-up-to-date-when-push.html">http://blog.rexzhao.com/2011/11/28/google-code-git-everything-up-to-date-when-push.html</a><br/>
第一次在 <code>Google Code</code> 上弄项目，注册完毕后，<br/>
尝试增加一个新文件用以测试 Git 是否好好工作。<br/>
结果在 <code>Push</code> 时却显示 <code>Every up-to-date</code>，检查文件时却发现实际上一个都没更新上去。</p>

<!-- more -->


<p>因为对 <code>Git</code> 不够熟悉，因此只好 <code>Googling</code>，进行一番搜索后找到原因如下：</p>

<p><strong>Why does Git refuse to push, saying "everything up to date"?<br/>
git push with no additional arguments only pushes branches that exist in the remote already. <br/>
If the remote repository is empty, nothing will be pushed. <br/>
In this case, explicitly specify a branch to push, e.g. <code>git push master</code>.</strong></p>

<p>也就是说一开始 <code>git</code> 服务器仓库是完全空的，<br/>
不包含任何一个分支(<code>branch</code>)，因此刚开始 <code>Push</code> 时需要指定一个。<br/>
执行 <code>git remote -v</code> 后看到自己的 <code>remote</code> 端名字为 <code>origin</code>:</p>

<pre><code>$ git remote -v
origin  https://code.google.com/p/micolog2 (fetch) 
origin  https://code.google.com/p/micolog2 (push)
</code></pre>


<p>执行 <code>git branch</code> 后看到自己当下用的分支是 <code>master</code>:</p>

<pre><code>$ git branch 
* master
</code></pre>


<p>因此在本地 <code>commit</code> 后，再执行 <code>git push origin master</code> 即可。</p>
]]></content>
  </entry>
  
</feed>
